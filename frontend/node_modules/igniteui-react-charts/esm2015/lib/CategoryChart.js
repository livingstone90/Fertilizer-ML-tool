/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { XYChart } from "./XYChart";
import { typeCast, runOn, delegateCombine, enumGetBox, markType, TypeRegistrar, getInstanceType } from "igniteui-react-core";
import { CategoryChartType_$type } from "./CategoryChartType";
import { CategorySeriesMarkerCollisionAvoidance_$type } from "./CategorySeriesMarkerCollisionAvoidance";
import { CategoryTransitionInMode_$type } from "./CategoryTransitionInMode";
import { TransitionInSpeedType_$type } from "./TransitionInSpeedType";
import { AutoMarginsAndAngleUpdateMode_$type } from "./AutoMarginsAndAngleUpdateMode";
import { AxisRangeBufferMode_$type } from "./AxisRangeBufferMode";
import { CategoryXAxis } from "./CategoryXAxis";
import { List$1 } from "igniteui-react-core";
import { DataSeriesType_$type } from "igniteui-react-core";
import { NumericYAxis } from "./NumericYAxis";
import { IDataSeriesAdapterRule_$type } from "igniteui-react-core";
import { SimpleCategorySeriesRule } from "igniteui-react-core";
import { SubCollectionsRule } from "igniteui-react-core";
import { Brush } from "igniteui-react-core";
import { AxisDefaults } from "./AxisDefaults";
import { Defaults } from "./Defaults";
import { Series } from "./Series";
import { HorizontalAnchoredCategorySeries } from "./HorizontalAnchoredCategorySeries";
import { ArrayExtension } from "igniteui-react-core";
import { AxisLabelSettings } from "./AxisLabelSettings";
import { DeviceUtils } from "igniteui-react-core";
import { CategoryChartMockDataGenerator } from "./CategoryChartMockDataGenerator";
import { stringIsNullOrEmpty } from "igniteui-react-core";
/**
 * @hidden
 */
export let CategoryChart = /*@__PURE__*/ (() => {
    class CategoryChart extends XYChart {
        constructor() {
            super();
            this.aew = 1000;
            this.ac1 = null;
            this.acl = 9;
            this.acn = 1;
            this.ac5 = false;
            this.ac6 = true;
            this.acp = 0;
            this.acz = 0;
            this.adt = 0;
            this.adw = 0;
            this.ads = 0;
            this.adv = 0;
            this.adu = 1;
            this.adx = 0;
            this.ad3 = NaN;
            this.ach = 1;
            this.ac7 = true;
            this.ac8 = true;
            this.adq = DeviceUtils.g(2);
            this.adr = DeviceUtils.g(60);
            this.adc = true;
            this.ac9 = true;
            this.adb = false;
            this.acj = 0;
            this.add = false;
            this.aex = 10;
            this.ad5 = NaN;
            this.ad4 = NaN;
            this.ad6 = 0;
            this.acd = null;
            this.ace = null;
            this.ada = true;
            this.ady = 3;
            this.adz = NaN;
            this.ad0 = NaN;
            this.ad1 = NaN;
            this.ad2 = NaN;
            this.ac3 = false;
            this.ac4 = false;
            this.adp = null;
            this.q9();
        }
        rr() {
            super.rr();
            if (this.dataChart == null) {
                return;
            }
            let a = this.dataChart.cu.j.e();
            this.acf = a.d;
            this.acg = a.e;
            if (this.abp == null) {
                this.abp = a.k;
            }
            if (this.abw == null) {
                this.abw = a.k;
            }
            this.xo = 0;
            this.abx = AxisDefaults.h;
            this.ab0 = null;
            this.abt = AxisDefaults.g;
            this.abq = null;
            this.w7 = AxisDefaults.f;
            this.abu = AxisDefaults.j;
            this.w8 = AxisDefaults.e;
            this.fc = true;
            this.fd = true;
            this.a7 = 0;
            this.hw = Defaults.j;
            this.t1 = Defaults.ae;
            this.tw = Defaults.af;
            this.tx = Defaults.ag;
            this.adh = true;
        }
        rt(a, b) {
            super.rt(a, b);
            a.hp = this.aey;
            a.cg = this.ac2;
        }
        se(a, b, c) {
            super.se(a, b, c);
            switch (a) {
                case "TransitionInDuration":
                    this.rg((d) => d.hp = this.aey);
                    break;
                case "TransitionInEasingFunction":
                    this.rg((d) => d.cg = this.ac2);
                    break;
            }
        }
        get aey() {
            return this.aew;
        }
        set aey(a) {
            let b = this.aey;
            if (a != b) {
                this.aew = a;
                this.sd("TransitionInDuration", b, this.aey);
            }
        }
        get ac2() {
            return this.ac1;
        }
        set ac2(a) {
            let b = this.ac2;
            if (a != b) {
                this.ac1 = a;
                this.sd("TransitionInEasingFunction", b, this.ac2);
            }
        }
        ae4() {
            let cvd_ = this.jv();
            cvd_.scaleByViewport();
            return (cvd_.serialize());
        }
        rm(a) {
            super.rm(a);
            a.ds = this.e8;
            a.uq = this.adi;
            a.ut = this.adj;
            a.vg = this.ad7;
            a.vh = this.ad8;
            a.tv = this.aci;
        }
        rs(a, b) {
            super.rs(a, b);
            let c = typeCast(HorizontalAnchoredCategorySeries.$, a);
            if (c == null) {
                return;
            }
            c.tn = this.aco;
            c.sk = this.adh;
            c.r4 = this.acq;
            c.ca = this.ac0;
            c.trendLineBrush = ArrayExtension.getModulus$1(Brush.$, this.ag, b);
            c.trendLineType = this.dj;
            c.trendLineThickness = this.iu;
            c.qh = this.cn(a, b);
            if (a.d4) {
                a.mq(ArrayExtension.getModulus$1(Brush.$, this.acf, b), ArrayExtension.getModulus$1(Brush.$, this.acg, b));
            }
        }
        acr() {
            return new CategoryXAxis();
        }
        acv() {
            return new NumericYAxis();
        }
        q5() {
            this.xAxis = this.acr();
            this.xAxis.name = "xAxis";
            let a = this.xAxis;
            a.propertyChanged = delegateCombine(a.propertyChanged, runOn(this, this.af6));
            this.yAxis = this.acv();
            this.yAxis.name = "yAxis";
            let b = this.yAxis;
            b.propertyChanged = delegateCombine(b.propertyChanged, runOn(this, this.af7));
            if (this.xAxis.ay == null) {
                this.xAxis.ay = new AxisLabelSettings();
            }
            if (this.yAxis.ay == null) {
                this.yAxis.ay = new AxisLabelSettings();
            }
        }
        aap(a) {
            super.aap(a);
            a.k8 = this.adl;
            a.lb = this.adn;
            a.b0 = this.adm;
        }
        aan(a) {
            super.aan(a);
            a.b0 = this.adk;
            a.zoomMaximumCategoryRange = this.ael;
            a.zoomToCategoryRange = this.aen;
            a.zoomToCategoryStart = this.aeo;
            a.zoomMaximumItemSpan = this.aem;
            a.zoomToItemSpan = this.aep;
        }
        get_bz() {
            return 0;
        }
        get bz() {
            return this.get_bz();
        }
        get acm() {
            return this.acl;
        }
        set acm(a) {
            if (a != this.acl) {
                let b = this.acm;
                this.acl = a;
                this.sd("ChartType", enumGetBox(CategoryChartType_$type, b), enumGetBox(CategoryChartType_$type, this.acm));
            }
        }
        get aco() {
            return this.acn;
        }
        set aco(a) {
            let b = this.aco;
            if (a != b) {
                this.acn = a;
                this.sd("MarkerCollisionAvoidance", enumGetBox(CategorySeriesMarkerCollisionAvoidance_$type, b), enumGetBox(CategorySeriesMarkerCollisionAvoidance_$type, this.aco));
            }
        }
        get adg() {
            return this.ac5;
        }
        set adg(a) {
            let b = this.adg;
            if (a != b) {
                this.ac5 = a;
                this.sd("IsSplineShapePartOfRange", b, this.adg);
            }
        }
        get adh() {
            return this.ac6;
        }
        set adh(a) {
            let b = this.adh;
            if (a != b) {
                this.ac6 = a;
                this.sd("IsTransitionInEnabled", b, this.adh);
            }
        }
        get acq() {
            return this.acp;
        }
        set acq(a) {
            let b = this.acq;
            if (a != b) {
                this.acp = a;
                this.sd("TransitionInMode", enumGetBox(CategoryTransitionInMode_$type, b), enumGetBox(CategoryTransitionInMode_$type, this.acq));
            }
        }
        get ac0() {
            return this.acz;
        }
        set ac0(a) {
            let b = this.ac0;
            if (a != b) {
                this.acz = a;
                this.sd("TransitionInSpeedType", enumGetBox(TransitionInSpeedType_$type, b), enumGetBox(TransitionInSpeedType_$type, this.ac0));
            }
        }
        get aeg() {
            return this.adt;
        }
        set aeg(a) {
            let b = this.aeg;
            if (a != b) {
                this.adt = a;
                this.sd("XAxisInterval", b, this.aeg);
            }
        }
        get aej() {
            return this.adw;
        }
        set aej(a) {
            let b = this.aej;
            if (a != b) {
                this.adw = a;
                this.sd("XAxisMinorInterval", b, this.aej);
            }
        }
        get aef() {
            return this.ads;
        }
        set aef(a) {
            let b = this.aef;
            if (a != b) {
                this.ads = a;
                this.sd("XAxisGap", b, this.aef);
            }
        }
        get aei() {
            return this.adv;
        }
        set aei(a) {
            let b = this.aei;
            if (a != b) {
                this.adv = a;
                this.sd("XAxisMinimumGapSize", b, this.aei);
            }
        }
        get aeh() {
            return this.adu;
        }
        set aeh(a) {
            let b = this.aeh;
            if (a != b) {
                this.adu = a;
                this.sd("XAxisMaximumGap", b, this.aeh);
            }
        }
        get aek() {
            return this.adx;
        }
        set aek(a) {
            let b = this.aek;
            if (a != b) {
                this.adx = a;
                this.sd("XAxisOverlap", b, this.aek);
            }
        }
        get aes() {
            return this.ad3;
        }
        set aes(a) {
            let b = this.aes;
            if (a != b) {
                this.ad3 = a;
                this.sd("YAxisInterval", b, this.aes);
            }
        }
        get aci() {
            return this.ach;
        }
        set aci(a) {
            let b = this.aci;
            if (a != b) {
                this.ach = a;
                this.sd("AutoMarginAndAngleUpdateMode", enumGetBox(AutoMarginsAndAngleUpdateMode_$type, b), enumGetBox(AutoMarginsAndAngleUpdateMode_$type, this.aci));
            }
        }
        af8() {
            if (this.dataChart != null) {
                this.dataChart.w1();
            }
        }
        get adi() {
            return this.ac7;
        }
        set adi(a) {
            let b = this.adi;
            if (a != b) {
                this.ac7 = a;
                this.sd("ShouldAutoExpandMarginForInitialLabels", b, this.adi);
            }
        }
        get adj() {
            return this.ac8;
        }
        set adj(a) {
            let b = this.adj;
            if (a != b) {
                this.ac8 = a;
                this.sd(CategoryChart.afd, b, this.adj);
            }
        }
        get ad7() {
            return this.adq;
        }
        set ad7(a) {
            let b = this.ad7;
            if (a != b) {
                this.adq = a;
                this.sd("AutoExpandMarginExtraPadding", b, this.ad7);
            }
        }
        get ad8() {
            return this.adr;
        }
        set ad8(a) {
            let b = this.ad8;
            if (a != b) {
                this.adr = a;
                this.sd("AutoExpandMarginMaximumValue", b, this.ad8);
            }
        }
        get adn() {
            return this.adc;
        }
        set adn(a) {
            let b = this.adn;
            if (a != b) {
                this.adc = a;
                this.sd("YAxisFavorLabellingScaleEnd", b, this.adn);
            }
        }
        get adk() {
            return this.ac9;
        }
        set adk(a) {
            let b = this.adk;
            if (a != b) {
                this.ac9 = a;
                this.sd(CategoryChart.afi, b, this.adk);
            }
        }
        get adm() {
            return this.adb;
        }
        set adm(a) {
            let b = this.adm;
            if (a != b) {
                this.adb = a;
                this.sd(CategoryChart.afw, b, this.adm);
            }
        }
        get ack() {
            return this.acj;
        }
        set ack(a) {
            let b = this.ack;
            if (a != b) {
                this.acj = a;
                this.sd("YAxisAutoRangeBufferMode", enumGetBox(AxisRangeBufferMode_$type, b), enumGetBox(AxisRangeBufferMode_$type, this.ack));
            }
        }
        get ado() {
            return this.add;
        }
        set ado(a) {
            let b = this.ado;
            if (a != b) {
                this.add = a;
                this.sd("YAxisIsLogarithmic", b, this.ado);
            }
        }
        get aez() {
            return this.aex;
        }
        set aez(a) {
            let b = this.aez;
            if (a != b) {
                this.aex = a;
                this.sd("YAxisLogarithmBase", b, this.aez);
            }
        }
        get aeu() {
            return this.ad5;
        }
        set aeu(a) {
            let b = this.aeu;
            if (a != b) {
                this.ad5 = a;
                this.sd("YAxisMinimumValue", b, this.aeu);
            }
        }
        get aet() {
            return this.ad4;
        }
        set aet(a) {
            let b = this.aet;
            if (a != b) {
                this.ad4 = a;
                this.sd("YAxisMaximumValue", b, this.aet);
            }
        }
        get aev() {
            return this.ad6;
        }
        set aev(a) {
            let b = this.aev;
            if (a != b) {
                this.ad6 = a;
                this.sd("YAxisMinorInterval", b, this.aev);
            }
        }
        get aee() {
            return this.xAxis.mv;
        }
        get aed() {
            return this.xAxis.mu;
        }
        aea() {
            return this.aee;
        }
        aec() {
            return this.aer;
        }
        ad9() {
            return this.aed;
        }
        aeb() {
            return this.aeq;
        }
        get aer() {
            return this.yAxis.lv;
        }
        get aeq() {
            return this.yAxis.lu;
        }
        get acf() {
            return this.acd;
        }
        set acf(a) {
            let b = this.acf;
            if (a != b) {
                this.acd = a;
                this.sd("NegativeBrushes", b, this.acf);
            }
        }
        get acg() {
            return this.ace;
        }
        set acg(a) {
            let b = this.acg;
            if (a != b) {
                this.ace = a;
                this.sd("NegativeOutlines", b, this.acg);
            }
        }
        get adl() {
            return this.ada;
        }
        set adl(a) {
            let b = this.adl;
            if (a != b) {
                this.ada = a;
                this.sd("YAxisAbbreviateLargeNumbers", b, this.adl);
            }
        }
        get ael() {
            return this.ady;
        }
        set ael(a) {
            let b = this.ael;
            if (a != b) {
                this.ady = a;
                this.sd("XAxisZoomMaximumCategoryRange", b, this.ael);
            }
        }
        get aem() {
            return this.adz;
        }
        set aem(a) {
            let b = this.aem;
            if (a != b) {
                this.adz = a;
                this.sd("XAxisZoomMaximumItemSpan", b, this.aem);
            }
        }
        get aen() {
            return this.ad0;
        }
        set aen(a) {
            let b = this.aen;
            if (a != b) {
                this.ad0 = a;
                this.sd("XAxisZoomToCategoryRange", b, this.aen);
            }
        }
        get aeo() {
            return this.ad1;
        }
        set aeo(a) {
            let b = this.aeo;
            if (a != b) {
                this.ad1 = a;
                this.sd("XAxisZoomToCategoryStart", b, this.aeo);
            }
        }
        get aep() {
            return this.ad2;
        }
        set aep(a) {
            let b = this.aep;
            if (a != b) {
                this.ad2 = a;
                this.sd("XAxisZoomToItemSpan", b, this.aep);
            }
        }
        get ade() {
            return this.ac3;
        }
        set ade(a) {
            let b = this.ade;
            if (a != b) {
                this.ac3 = a;
                this.sd("IsCategoryHighlightingEnabled", b, this.ade);
            }
        }
        get adf() {
            return this.ac4;
        }
        set adf(a) {
            let b = this.adf;
            if (a != b) {
                this.ac4 = a;
                this.sd("IsItemHighlightingEnabled", b, this.adf);
            }
        }
        get_gf() {
            let a = new List$1(DataSeriesType_$type, 0);
            if (TypeRegistrar.isRegistered("AreaSeries")) {
                a.add(2);
            }
            if (TypeRegistrar.isRegistered("ColumnSeries")) {
                a.add(1);
            }
            if (TypeRegistrar.isRegistered("LineSeries")) {
                a.add(0);
            }
            if (TypeRegistrar.isRegistered("PointSeries")) {
                a.add(10);
            }
            if (TypeRegistrar.isRegistered("SplineSeries")) {
                a.add(6);
            }
            if (TypeRegistrar.isRegistered("SplineAreaSeries")) {
                a.add(7);
            }
            if (TypeRegistrar.isRegistered("StepAreaSeries")) {
                a.add(5);
            }
            if (TypeRegistrar.isRegistered("StepLineSeries")) {
                a.add(4);
            }
            if (TypeRegistrar.isRegistered("WaterfallSeries")) {
                a.add(8);
            }
            return a;
        }
        get gf() {
            return this.get_gf();
        }
        gj() {
            if (this.adp == null) {
                this.adp = CategoryChartMockDataGenerator.a();
            }
            return this.adp;
        }
        cm(a) {
            if (a != null) {
                let b = super.cm(a);
                if (b == 2) {
                    if (a.d3 && this.fn) {
                        return 13;
                    }
                }
            }
            return super.cm(a);
        }
        get_f3() {
            return this.xAxis != null && this.xAxis.categoryMode != 0;
        }
        af6(a, b) {
            switch (b.propertyName) {
                case "ActualMinimum":
                    this.sl("XAxisActualMinimum");
                    break;
                case "ActualMaximum":
                    this.sl("XAxisActualMaximum");
                    break;
            }
        }
        af7(a, b) {
            switch (b.propertyName) {
                case "ActualMinimumValue":
                    this.sl("YAxisActualMinimum");
                    break;
                case "ActualMaximumValue":
                    this.sl("YAxisActualMaximum");
                    break;
            }
        }
        sx() {
            super.sx();
            this.xAxis.fz = this.xy == null ? XYChart.ya(this.xAxis, this.bb.dataSeries) : this.xy;
            this.xAxis.itemsSource = this.dataChart != null && this.dataChart.series.count > 0 ? this.dataChart.series._inner[0].itemsSource : null;
            if (this.adi) {
                this.r5((a) => a.w1());
            }
        }
        get xAxis() {
            return this._xAxis;
        }
        set xAxis(a) {
            this._xAxis = a;
        }
        get yAxis() {
            return this._yAxis;
        }
        set yAxis(a) {
            this._yAxis = a;
        }
        acu(a, b) {
            switch (a) {
                case 2: return this.cx(1);
                case 3: return this.cx(10);
                case 0: return this.cx(0);
                case 1: return this.cx(2);
                case 6: return this.cx(6);
                case 7: return this.cx(7);
                case 4: return this.cx(4);
                case 5: return this.cx(5);
                case 8: return this.cx(8);
                case 9: return this.act(b);
                default: return this.cx(1);
            }
        }
        act(a) {
            return this.cx(a);
        }
        ba(a) {
            switch (this.acm) {
                case 1: return 2;
                case 0: return 0;
                case 3: return 10;
                case 6: return 6;
                case 7: return 7;
                case 5: return 5;
                case 4: return 4;
                case 8: return 8;
                case 9: return a.suggestedSeries;
                default:
                case 2: return 1;
            }
        }
        cw(a, b) {
            let c = this.acu(this.acm, a.suggestedSeries);
            c.t5 = a.findMatchingHint(0).path;
            c.xAxis = this.xAxis;
            c.yAxis = this.yAxis;
            return c;
        }
        sv(a) {
            if (a.suggestedSecondaryAxis == 2) {
                this.yAxis.lg = true;
                this.yAxis.l7 = 10;
            }
        }
        sy() {
            this.yAxis.lg = this.ado;
            this.yAxis.l7 = this.aez;
        }
        get_ge() {
            return ((() => {
                let $ret = new List$1(IDataSeriesAdapterRule_$type, 0);
                $ret.add(new SimpleCategorySeriesRule());
                $ret.add(new SubCollectionsRule());
                return $ret;
            })());
        }
        get ge() {
            return this.get_ge();
        }
        q1(a, b) {
            let c = typeCast(HorizontalAnchoredCategorySeries.$, a);
            if (c != null) {
                c.tn = this.aco;
                c.qh = this.cn(a, b);
            }
        }
        af4(a) {
            this.af5((b, c) => a(b));
        }
        af5(a) {
            if (this.dataChart == null) {
                return;
            }
            for (let b = 0; b < this.dataChart.series.count; b++) {
                let c = typeCast(HorizontalAnchoredCategorySeries.$, this.dataChart.series._inner[b]);
                if (c == null) {
                    continue;
                }
                a(c, b);
            }
        }
        vg() {
            return this.xAxis;
        }
        vh() {
            return this.yAxis;
        }
        acx() {
            return this.cx(30);
        }
        acy() {
            return this.cx(31);
        }
        gb(a, b) {
            let c = super.gb(a, b);
            if (c != null) {
                let d = new List$1(Series.$, 0);
                if (this.ac3) {
                    d.add(this.acx());
                }
                if (this.ac4) {
                    d.add(this.acy());
                }
                for (let e = 0; e < d.count; e++) {
                    let f = d._inner[e];
                    f.name = a + getInstanceType(f).typeName;
                    c.add(f);
                }
            }
            return c;
        }
        a5() {
            if (this.a4 == 0) {
                return 1;
            }
            else {
                return this.a4;
            }
        }
        s2(a, b, c) {
            super.s2(a, b, c);
            if (this.bb.dataSeries.count > 0) {
                if (stringIsNullOrEmpty(this.k7)) {
                    this.b1.setXMemberPath(a, c.getMemberPathFor(16));
                }
                if (stringIsNullOrEmpty(this.k9)) {
                    this.b1.setYMemberPath(a, c.getMemberPathFor(0));
                }
                if (stringIsNullOrEmpty(this.k3)) {
                    this.b1.setLabelMemberPath(a, c.getMemberPathFor(0));
                }
                if (stringIsNullOrEmpty(this.k0)) {
                    this.b1.setContentMemberPath(a, c.getMemberPathFor(0));
                }
            }
        }
        fq() {
            if (this.a7 == 4 || this.a7 == 3) {
                return true;
            }
            else if (this.a7 == 0) {
                if (this.acm == 2 || this.acm == 8) {
                    return false;
                }
                else if (this.acm == 9 && this.bb != null && this.bb.dataSeries != null && this.bb.dataSeries.count > 0) {
                    let a = this.bb.dataSeries._inner[0].suggestedSeries;
                    if (a == 1 || a == 8) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }
        sd(a, b, c) {
            super.sd(a, b, c);
            switch (a) {
                case "ChartType":
                    this.sx();
                    break;
                case "MarkerCollisionAvoidance":
                    this.af4((d) => d.tn = this.aco);
                    break;
                case "IsTransitionInEnabled":
                    this.af4((d) => d.sk = this.adh);
                    break;
                case "IsSplineShapePartOfRange":
                    this.af4((d) => {
                        if (d.eh) {
                            d.mr(this.adg);
                        }
                    });
                    break;
                case "TransitionInMode":
                    this.af4((d) => d.r4 = this.acq);
                    break;
                case "TransitionInSpeedType":
                    this.af4((d) => d.ca = this.ac0);
                    break;
                case "XAxisInterval":
                    this.xAxis.mq = this.aeg;
                    break;
                case "XAxisMinorInterval":
                    this.xAxis.mr = this.aej;
                    break;
                case "XAxisGap":
                    this.xAxis.k0 = this.aef;
                    break;
                case "XAxisOverlap":
                    this.xAxis.k9 = this.aek;
                    break;
                case "XAxisMinimumGapSize":
                    this.xAxis.k8 = this.aei;
                    break;
                case "XAxisMaximumGap":
                    this.xAxis.k7 = this.aeh;
                    break;
                case "XAxisZoomMaximumCategoryRange":
                    this.xAxis.zoomMaximumCategoryRange = this.ael;
                    break;
                case "XAxisZoomMaximumItemSpan":
                    this.xAxis.zoomMaximumItemSpan = this.aem;
                    break;
                case "XAxisZoomToCategoryRange":
                    this.xAxis.zoomToCategoryRange = this.aen;
                    break;
                case "XAxisZoomToCategoryStart":
                    this.xAxis.zoomToCategoryStart = this.aeo;
                    break;
                case "XAxisZoomToItemSpan":
                    this.xAxis.zoomToItemSpan = this.aep;
                    break;
                case "YAxisInterval":
                    this.yAxis.lz = this.aes;
                    break;
                case "YAxisFavorLabellingScaleEnd":
                    this.yAxis.lb = this.adn;
                    break;
                case "YAxisAutoRangeBufferMode":
                    this.yAxis.ks = this.ack;
                    break;
                case "YAxisIsLogarithmic":
                    this.yAxis.lg = this.ado;
                    break;
                case "YAxisLogarithmBase":
                    this.yAxis.l7 = this.aez;
                    break;
                case "YAxisMinimumValue":
                    this.yAxis.l3 = this.aeu;
                    break;
                case "YAxisMaximumValue":
                    this.yAxis.l2 = this.aet;
                    break;
                case "YAxisMinorInterval":
                    this.yAxis.l4 = this.aev;
                    break;
                case "NegativeBrushes":
                case "NegativeOutlines":
                    this.af5((d, e) => {
                        if (d.d4) {
                            d.mq(ArrayExtension.getModulus$1(Brush.$, this.acf, e), ArrayExtension.getModulus$1(Brush.$, this.acg, e));
                        }
                    });
                    break;
                case "YAxisAbbreviateLargeNumbers":
                    this.aaw((d) => d.k8 = this.adl);
                    break;
                case "IsCategoryHighlightingEnabled":
                case "IsItemHighlightingEnabled":
                    this.sx();
                    break;
                case "AutoMarginAndAngleUpdateMode":
                    this.r5((d) => d.tv = this.aci);
                    break;
                case "ShouldAutoExpandMarginForInitialLabels":
                    this.r5((d) => d.uq = this.adi);
                    break;
                case CategoryChart.afd:
                    this.r5((d) => d.ut = this.adj);
                    break;
                case "AutoExpandMarginExtraPadding":
                    this.r5((d) => d.vg = this.ad7);
                    break;
                case "AutoExpandMarginMaximumValue":
                    this.r5((d) => d.vh = this.ad8);
                    break;
                case CategoryChart.afi:
                    this.aas((d) => d.b0 = this.adk, a);
                    break;
                case CategoryChart.afw:
                    this.aaw((d) => d.b0 = this.adm);
                    break;
            }
        }
    }
    CategoryChart.$t = /*@__PURE__*/ markType(CategoryChart, 'CategoryChart', XYChart.$);
    CategoryChart.afd = "ShouldConsiderAutoRotationForInitialLabels";
    CategoryChart.afi = "XAxisEnhancedIntervalPreferMoreCategoryLabels";
    CategoryChart.afw = "YAxisEnhancedIntervalPreferMoreCategoryLabels";
    return CategoryChart;
})();
